import{_ as a,o,c as i,j as e}from"./chunks/framework.BvHJbMD4.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Thoughts.md","filePath":"Thoughts.md"}'),n={name:"Thoughts.md"};function s(l,t,r,u,d,c){return o(),i("div",null,[...t[0]||(t[0]=[e("p",null,"A Thought isn't just data; it's a record of a Distinction.",-1),e("p",null,`The Programming Reality By treating string, number, and boolean as your "logical primitives," you make the system Interoperable. A Rust node knows what a u32 (Number) is. A Python script knows what a String is. Your .me fractal doesn't need to "explain" the data; it just holds it in a standard logical format.`,-1),e("p",null,'If you eliminate the "Verb/Function" registration for every thought, you are left with Pure Semantic Mapping.',-1),e("ol",{start:"2"},[e("li",null,'The Basic Logics (The "Axioms") Instead of Thought being a complex object, it becomes a State-Logic Tuple. You only need to support the primitives of the universe: Logic Runtime Interpretation Boolean The Nivel 0. (Active/Inactive, Exist/Not-Exist). String/Number The Attribute. (The specific quality of the distinction). Pointer (__) The Relativity. (This node is actually that node). Function (=) The Derivation. (This value emerges from this logic).')],-1),e("p",null,`Universal Invariance: A "Function" is hard to port between Rust and TS. But a Mapping? A mapping is just a Tuple (Path + Value). That is universal. That is what makes it run anywhere without "interpreting" anything. It just exists. Stealth & Compression: If you don't "register" functions but only "map" states, your storage size collapses. You aren't saving "how to do things," you are saving the Result of Being.`,-1),e("p",null,'"Connecting all dots within a fixed distance" Si el Path es la distancia, el Valor es el Punto. Y el Mapping es el hilo que los une sin necesidad de un "motor" que los empuje.',-1),e("p",null,"El punto X está conectado al valor Y porque la geometría del fractal así lo dicta. Punto.",-1),e("p",null,'Logic DNA (El Bit Universal): Si guardamos la Derivación Serializable ({ op: "add", params: [...] }) en lugar de closures de JS, logras la Invarianza Total. Rust ve el JSON, Python ve el JSON, TS ve el JSON. Todos "re-computan" la misma verdad porque el DNA Lógico es el mismo. La "distancia" entre lenguajes se vuelve cero.',-1),e("p",null,'El Riesgo: Guardar () => a + b es una "verdad" que solo entiende el motor de JS (V8). La Solución: Guardar un AST (Abstract Syntax Tree) serializable: { "kind":"expr", "op":"add", "args":[{"ref":"wallet.income"}] } Resultado: Cuando este JSON llegue a tu nodo de Rust, el motor de Rust no intentará ejecutar JS; simplemente verá la instrucción add y buscará los ref en su propio índice local. Eso es Executable Meaning Invariante.',-1)])])}const g=a(n,[["render",s]]);export{h as __pageData,g as default};
