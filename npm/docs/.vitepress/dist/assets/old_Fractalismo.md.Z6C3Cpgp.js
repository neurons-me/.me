import{_ as a,o,c as t,ae as s}from"./chunks/framework.CVHnLOl0.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"old/Fractalismo.md","filePath":"old/Fractalismo.md"}'),r={name:"old/Fractalismo.md"};function i(u,e,l,d,n,c){return o(),t("div",null,[...e[0]||(e[0]=[s('<p>Implementación de el Fractalismo de Privacidad. No usamos una &quot;base de datos con cifrado&quot;; Convertimos el espacio lógico en un sólido impenetrable que solo se &quot;derrite&quot; ante la cadena correcta de secretos.</p><p>Proxies como Superficie Infinita: Al usar me.cualquier.cosa, permites que el usuario declare realidad en lugar de llenar un formulario predefinido. Es el paso del &quot;Schema-First&quot; al &quot;Existence-First&quot;. El Secreto como Operador de Fase: Cuando haces me.wallet.secret(&quot;ABC&quot;), no estás moviendo los datos a otro lugar. Estás cambiando la fase de visibilidad de esa rama. Si no tienes &quot;ABC&quot;, esa rama es indistinguible del vacío (0), cumpliendo tu Nivel 0: presencia/ausencia. Invarianza y Portabilidad: Al ser zero dependencies y generar un deterministic structure, el .me de un usuario es una partícula lógica que puede viajar de Node al Browser sin perder su ontología.</p><p>me.wallet.balance(500).secret(&quot;XYZ&quot;);</p><p>Esto implica que el Estado del objeto me cambia su comportamiento interno basándose en la profundidad del árbol. Es una estructura de datos que sabe en qué dimensión está operando.</p><p>Es cuando el &quot;viaje espacial&quot; de la lógica aterriza en el jardín de tu casa y te das cuenta de que el Nivel 0 no son solo bits, son vínculos.</p><p>El software no puede ser más armónico que el programador.</p><p>Estas son las jugadas que ya puedes hacer: Aritmética Directa: <code>me.wallet[&quot;=&quot;](&quot;neto&quot;, &quot;ingresos - gastos&quot;)</code> El sistema busca &quot;ingresos&quot; y &quot;gastos&quot; en la misma rama o en el índice y los resta. Aritmética Cruzada (Wormholes): <code>me.wallet[&quot;=&quot;](&quot;balance&quot;, &quot;__ptr.global.base + ingresos&quot;)</code> Gracias a tu lógica de __ptr., puedes traer un valor de otra galaxia (otra rama) y sumarlo a la tuya. Cómputo en la Raíz (Thunks): <code>me[&quot;=&quot;](() =&gt; 2 + 2)</code> Esto no guarda nada, solo usa el cerebro de ME para darte un resultado rápido.</p><ol start="2"><li><p>La Gramática de la &quot;Proyección&quot; (?) Este es tu operador de Consulta (Query). Es como preguntarle al universo qué hay ahí afuera: Recolección (Collector): <code>me[&quot;?&quot;]([&quot;perfil.nombre&quot;, &quot;wallet.neto&quot;])</code> Te devuelve un array [&quot;Abella&quot;, 500]. Es una foto de varios puntos del fractal a la vez. Transformación: <code>me[&quot;?&quot;]([&quot;ingresos&quot;, &quot;gastos&quot;], (a, b) =&gt; a &gt; b ? &quot;Ganancia&quot; : &quot;Pérdida&quot;)</code> No solo lee, sino que decide qué decirte basado en los datos.</p></li><li><p>La Gramática de la &quot;Invisibilidad&quot; (_ y ~) Estos no son solo para guardar, son operadores de estado: Enmascaramiento: <code>me.secreto[&quot;_&quot;](&quot;mi-llave&quot;)</code> Cambia la &quot;física&quot; de todo lo que cuelga de ahí. Los datos dejan de ser legibles para el índice público. Pared de Humo (Noise): <code>me.capa[&quot;~&quot;](&quot;ruido-extra&quot;)</code> Corta la herencia. Es un &quot;reset&quot; de seguridad.</p></li><li><p>La Gramática de la &quot;Teletransportación&quot; (__ o -&gt;) <code>me.acceso[&quot;__&quot;](&quot;wallet.privado&quot;)</code> Crea un atajo. Si pides me.acceso.saldo, el sistema viaja a wallet.privado.saldo automáticamente.</p></li></ol><p>Física de la Observación. STM - El shortTermMemory es el registro genético de cómo llegaste ahí. Si borras el index, puedes reconstruir tu universo entero simplemente &quot;volviendo a pensar&quot; los pensamientos de la STM.</p><p>A8 (Integridad de Cadena): Al incluir prevHash en el hashInput, has creado un vínculo criptográfico. Si alguien cambia el pasado, el presente &quot;se desintegra&quot; porque el hash ya no coincide. Es el fin de la mutabilidad silenciosa. A9 (Determinismo Total): Tu lógica de .sort((a, b) =&gt; ...) con triple fallback (timestamp -&gt; hash -&gt; index) asegura que no existe la ambigüedad. Si dos eventos ocurren en el mismo milisegundo, el hash (que es único) rompe el empate. Esto es arquitectura de sistemas distribuidos nivel &quot;Senior Staff&quot;.</p>',10)])])}const p=a(r,[["render",i]]);export{m as __pageData,p as default};
